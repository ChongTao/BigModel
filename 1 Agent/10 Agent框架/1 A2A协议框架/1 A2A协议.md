# 一 介绍

**[Agent2Agent (A2A) 协议](https://a2a-protocol.org/latest/)**是由 Google 开发并捐赠给 Linux 基金会的开放标准，旨在实现 AI 代理之间的无缝通信和协作。在代理由不同框架和不同供应商构建的世界中，A2A 提供了一种通用语言，打破了孤岛并促进了互操作性。

![A2A](https://a2a-protocol.org/latest/assets/a2a-mcp-readme.png)

# 二 A2A的核心概念

A2A 的基础组成部分包括核心参与者、智能体卡片、智能体发现、通信与任务、交互机制以及安全性。

## 2.1 核心参与者-Core Actors

核心参与者: A2A 涉及三个主要实体:

- 用户 (User): 发起智能体协助请求。
- A2A 客户端 (客户端智能体): 代表用户请求操作或信息的应用程序或 AI 智能体。
- A2A 服务器 (远程智能体): 提供 HTTP 端点以处理客户端请求并返回结果的 AI 智能体或系统。远程智能体作为「不透明」系统运行, 这意味着客户端无需了解其内部操作细节。

![A2A_Client](https://a2a-protocol.org/latest/assets/a2a-actors.png)

## 2.2 智能体卡片-Agent Card

智能体的数字身份由其智能体卡片 (Agent Card) 定义, 通常是 JSON 文件。该文件包含用于客户端交互和自动发现的关键信息, 包括智能体的身份、端点 URL 和版本。它还详细说明了支持的功能 (如流式传输或推送通知)、特定技能、默认输入/输出模式以及身份验证要求。

```json
export interface AgentCard {
  protocolVersion: string;
  
  name: string;

  description: string;

  url: string;

  preferredTransport?: TransportProtocol | string;

  additionalInterfaces?: AgentInterface[];
 
  provider?: AgentProvider;
 
  version: string;
 
  capabilities: AgentCapabilities;

  securitySchemes?: { [scheme: string]: SecurityScheme };

  security?: { [scheme: string]: string[] }[];

  defaultInputModes: string[];

  defaultOutputModes: string[];

  skills: AgentSkill[];

  supportsAuthenticatedExtendedCard?: boolean;

  signatures: AgentCardSignature[];
}
```

## 2.3 智能体发现-Agent discovery

它允许客户端找到描述可用 A2A 服务器能力的智能体卡片。此过程存在多种策略:

- Well-Known URI: 智能体在标准化路径 (例如/.well-known/agent.json) 上托管其智能体卡片。这种方法为公共或特定领域的使用提供了广泛且通常是自动化的可访问性。
- 托管注册中心 (Curated Registries): 这些注册中心提供了一个集中的目录, 智能体卡片在此发布, 并可根据特定标准进行查询。这非常适合需要集中管理和访问控制的企业环境。
- 直接配置 (Direct Configuration): 智能体卡片信息被嵌入或私下共享。此方法适用于动态发现不那么重要的紧密耦合或私有系统。

## 2.3 通信与任务-Communications and Tasks

在 A2A 框架中, 通信围绕异步任务构建, 异步任务是长时间运行流程的基本工作单元。每个任务都被分配唯一标识符, 并经历一系列状态——例如已提交、处理中或已完成——这种设计支持复杂操作中的并行处理。智能体之间的通信通过消息 (Message) 进行。

消息包含 `attributes` 和一个或多个 `part`。`attributes` 是描述消息的键值元数据, 如其优先级或创建时间。`part` 承载实际交付的内容, 如纯文本、文件或结构化 JSON 数据。智能体在任务期间生成的具体输出被称为 `artifacts`。与消息类似, `artifacts` 也由一个或多个部分组成, 并且可以在结果可用时以增量方式流式传输。A2A 框架内的所有通信都通过 HTTP(S) 进行, 并使用 JSON-RPC 2.0 协议作为负载。为了在多次交互中保持连续性, 使用服务器生成的 `contextId` 来对相关任务进行分组并保留上下文。

A2A 明确可使用多种 transport：

- JSON-RPC 2.0（最基础标准）

  - 用 POST 请求传 JSON

  - A2A 的默认调用格式

  - 标准化 request / response / error 编码

- gRPC（高性能可选传输）

  - 适用于高吞吐 Agent 网络

  - 提供严格 schema、双向流式传输

- HTTP + SSE Stream

  - 用于流式内容（LLM token、日志、进度流）

  - 支持持续输出任务结果

- WebSocket（可选）
  - 对实时 agent 协作有帮助

## 2.4 交互机制-Interaction Mechanisms 

A2A 提供了多种交互方法以适应各种 AI 应用需求, 每种方法都有其独特的机制:

- 同步请求/响应: 用于快速、即时的操作。在这种模型中, 客户端发送请求并主动等待服务器处理, 服务器在单个同步交换中返回完整响应。

- 异步轮询: 适用于需要较长时间处理的任务。客户端发送一个请求, 服务器立即以 “处理中” 状态和任务 ID 进行确认。然后客户端可以自由执行其他操作, 并可以通过发送新请求定期轮询服务器以检查任务状态, 直到任务被标记为 “已完成” 或 “失败”。

- 流式更新 (服务器发送事件-SSE): 非常适合接收实时、增量的结果。此方法建立了一个从服务器到客户端的持久性单向连接。它允许远程智能体持续推送更新, 例如状态变更或部分结果, 而无需客户端发出多个请求。

- 推送通知 (Webhooks): 专为运行时间很长或资源密集型的任务设计, 在这些任务中维持长连接或频繁轮询效率低。客户端可以注册 webhook URL, 当任务状态发生重大变化 (例如完成时), 服务器将向该 URL 发送异步通知 (「推送」)。

  ```json
  # 同步请求示例
  {
    "jsonrpc": "2.0",
    "id": "1",
    "method": "sendTask",
    "params": {
      "id": "task-001",
      "sessionId": "session-001",
      "message": {
        "role": "user",
        "parts": [
          {
            "type": "text",
            "text": "What is the exchange rate from USD to EUR?"
          }
        ]
      },
      "acceptedOutputModes": [
        "text/plain"
      ],
      "historyLength": 5
    }
  }
  ```

  同步请求示例使用 `sendTask` 方法, 客户端发起请求并期望得到单一、完整的响应。相比之下, 流式请求使用 `sendTaskSubscribe` 方法建立持久连接, 允许智能体随时间推移发回多个增量更新或部分结果。

  ```go
  # 流式请求示例
  {
    "jsonrpc": "2.0",
    "id": "2",
    "method": "sendTaskSubscribe",
    "params": {
      "id": "task-002",
      "sessionId": "session-001",
      "message": {
        "role": "user",
        "parts": [
          {
            "type": "text",
            "text": "What's the exchange rate for JPY to GBP today?"
          }
        ]
      },
      "acceptedOutputModes": [
        "text/plain"
      ],
      "historyLength": 5
    }
  }
  ```


## 2.5 安全性-Security 

智能体间通信 (A2A): 智能体间通信 (A2A) 是系统架构的重要组成部分, 它实现了智能体之间安全、无缝的数据交换。通过多种内置机制, 它确保了系统的稳健性和完整性。

- 双向传输层安全 (TLS): 建立加密和认证的连接, 以防止未经授权的访问和数据拦截, 确保通信安全。
- 全面的审计日志: 所有智能体间的通信都被详细记录, 包括信息流、涉及的智能体和执行的操作。这个审计跟踪对于问责、故障排查和安全分析至关重要。
- 智能体卡片声明: 身份验证要求在智能体卡片中明确声明, 这是概述智能体身份、能力和安全策略的配置工件。这使得身份验证管理得以集中和简化。
- 凭证处理: 智能体通常使用安全的凭证 (如 OAuth 2.0 令牌或 API 密钥) 进行身份验证, 这些凭证通过 HTTP 标头传递。这种方法可以防止凭证在 URL 或消息体中暴露, 从而增强整体安全性。

# 三 A2A生命周期

A2A 请求生命周期是遵循的四个主要步骤：代理发现、身份验证、`sendMessage`API 和`sendMessageStream`API。下图更深入地展示了操作流程，说明了客户端、A2A 服务器和身份验证服务器之间的交互。详情见[a2a生命周期](https://a2a-protocol.org/latest/topics/what-is-a2a/#a2a-request-lifecycle)

# 四 A2A vs MCP

A2A 是与 Anthropic 模型上下文协议 (Model Context Protocol, MCP) 互补的协议。MCP 侧重于为智能体及其与外部数据和工具的交互构建上下文, 而 A2A 则促进智能体之间的协调与通信, 从而实现任务委派和协作。



![](https://github.com/ginobefun/agentic-design-patterns-cn/blob/main/images/chapter15_fig1.png?raw=true)

A2A 的目标是在开发复杂的多智能体 AI 系统时提高效率、降低集成成本, 并促进创新和互操作性。因此, 深入理解 A2A 的核心组件和操作方法对于在构建协作和互操作的 AI 智能体系统中有效设计、实施和应用至关重要。



# 五 A2A开源项目

## 5.1 a2aproject

官方 Go SDK，完全遵守 A2A 协议规范，用来构建 A2A server/client。适合从底层搭建 A2A agent 服务。 其中包括：

- [A2A](https://github.com/a2aproject/A2A)：各个语言协议定义
- [a2a-go](https://github.com/a2aproject/a2a-go)：Go语言实现A2A协议
- [a2a-python](https://github.com/a2aproject/a2a-python)：Python语言实现A2A协议
- [a2a-java](https://github.com/a2aproject/a2a-java)：Java语言实现A2A协议
- [a2a-samples](https://github.com/a2aproject/a2a-samples)：官方示例代码仓库，提供多语言实现和演示应用，帮助开发者学习和使用 A2A 协议

详细信息见[a2aproject](./1 a2aproject)

## 5.2 trpc-a2a-go

tRPC 团队推出的 Go 实现，提供完整 client/server 支持、流 (streaming)、session 管理、认证 (JWT / OAuth2 / API Key) 等，适合构建较复杂 agent 网络与服务。

- [trpc-a2a-go](https://github.com/trpc-group/trpc-a2a-go?utm_source=chatgpt.com)：Agent框架
- [tRPC-Agent-Go](https://github.com/trpc-group/trpc-agent-go)：基于框架增加各种模块，如会话管理、规划等

更多信息见[tRPC-agent-Go](./2 tRPC-Agent-Go)

## 5.3 yeeaiclub/a2a-go

社区实现的 A2A Go SDK，实现了 A2A 协议绝大多数方法 (任务发送、取消、流式任务、鉴权等)，适合作为轻量级 A2A client/server 基础。([GitHub](https://github.com/yeeaiclub/a2a-go?utm_source=chatgpt.com))



# 6 A2A协议

以[a2a.proto](https://github.com/a2aproject/A2A/blob/main/specification/grpc/a2a.proto)定义标准PRC接口为例（A2AService标准接口定义）

| 类别       | 操作                             | 说明                                   |
| :--------- | :------------------------------- | :------------------------------------- |
| 消息操作   | SendMessage                      | 发送消息给 Agent，返回 Task 或直接响应 |
|            | SendStreamingMessage             | 流式版本，实时返回更新                 |
| 任务管理   | GetTask                          | 获取任务当前状态                       |
|            | ListTasks                        | 列出任务（支持过滤和分页）             |
|            | CancelTask                       | 取消任务                               |
|            | SubscribeToTask                  | 订阅任务更新（流式）                   |
| 推送通知   | SetTaskPushNotificationConfig    | 设置 Webhook 通知                      |
|            | GetTaskPushNotificationConfig    | 获取通知配置                           |
|            | ListTaskPushNotificationConfig   | 列出所有通知配置                       |
|            | DeleteTaskPushNotificationConfig | 删除通知配置                           |
| Agent 发现 | GetExtendedAgentCard             | 获取扩展 Agent Card                    |
