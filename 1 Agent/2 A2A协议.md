# 一 定义

**[Agent2Agent (A2A) 协议](https://a2a-protocol.org/latest/)**是由 Google 开发并捐赠给 Linux 基金会的开放标准，旨在实现 AI 代理之间的无缝通信和协作。在代理由不同框架和不同供应商构建的世界中，A2A 提供了一种通用语言，打破了孤岛并促进了互操作性。

Agent和MCP之间是互补

![image-20251021163450799](D:\open_source\github\BigModel\1 Agent\assets\image-20251021163450799-1761035695562-1.png)

# 二、Agent2Agent的生命周期

A2A 请求生命周期是遵循的四个主要步骤：代理发现、身份验证、`sendMessage`API 和`sendMessageStream`API。下图更深入地展示了操作流程，说明了客户端、A2A 服务器和身份验证服务器之间的交互。

![image-20251021164143851](D:\open_source\github\BigModel\1 Agent\assets\image-20251021164143851-1761036110292-3.png)

# 三 Agent2Agent角色

- **用户**：发起请求（人工或自动化服务）。
- **A2A** **客户端（客户端代理）：**代表用户向远程代理请求操作或信息的应用程序、服务或其他 AI 代理。客户端使用 A2A 协议发起通信。
- **A2A 服务器（远程代理）：**一种 AI 代理或代理系统，它公开一个实现 A2A 协议的 HTTP 端点。它接收来自客户端的请求，处理任务，并返回结果或状态更新。从客户端的角度来看，远程代理是一个“不透明”的系统，这意味着客户端不需要了解其内部工作原理、内存或工具

## 3.1 代理卡

描述 A2A 服务器的JSON 元数据文档，描述代理的身份（名称、描述）、服务端点 URL、版本、支持的 A2A 功能，它提供的特定技能、默认输入/输出模式和身份验证要求。客户使用代理卡来发现代理并了解如何安全有效地与它们互动

> `/.well-known/agent-card.json`描述 A2A 服务器的JSON 元数据文档

客户可以通过多种方式查找代理卡，包括但不限于：

- **Well-Known URI**：访问代理域上的预定义路径（例如：https://{server_domain}/.well-known/agent-card.json， 通过默认的域名获取）。
- **注册表/目录：**查询代理的目录或注册表。
- **直接配置：**客户端可以预先配置代理卡URL或卡内容本身。

代理卡本身可能包含被视为敏感的信息。

- 如果代理卡包含敏感信息，则服务该卡的端点**必须**受到适当的访问控制的保护。
- 通常**不建议**将明文密钥（例如静态 API 密钥）直接包含在代理卡中。建议采用客户端通过带外方式获取动态凭证的身份验证方案。

AgentCard定义：

```SQL
/**
 * The AgentCard is a self-describing manifest for an agent. It provides essential
 * metadata including the agent's identity, capabilities, skills, supported
 * communication methods, and security requirements.
 */
export interface AgentCard {
  /**
   * The version of the A2A protocol this agent supports. 版本信息
   * @default "0.3.0" 
   */
  protocolVersion: string;
  /**
   * A human-readable name for the agent.  agent名称
   *
   * @TJS-examples ["Recipe Agent"]
   */
  name: string;
  /**
   * A human-readable description of the agent, assisting users and other agents
   * in understanding its purpose.
   *
   * @TJS-examples ["Agent that helps users with recipes and cooking."]
   */
  description: string;
  /**
   * The preferred endpoint URL for interacting with the agent.
   * This URL MUST support the transport specified by 'preferredTransport'.
   *
   * @TJS-examples ["https://api.example.com/a2a/v1"]
   */
  url: string;
  /**
   * The transport protocol for the preferred endpoint (the main 'url' field).
   * If not specified, defaults to 'JSONRPC'.
   *
   * IMPORTANT: The transport specified here MUST be available at the main 'url'.
   * This creates a binding between the main URL and its supported transport protocol.
   * Clients should prefer this transport and URL combination when both are supported.
   *
   * @default "JSONRPC"
   * @TJS-examples ["JSONRPC", "GRPC", "HTTP+JSON"]
   */
  preferredTransport?: TransportProtocol | string;
  /**
   * A list of additional supported interfaces (transport and URL combinations).
   * This allows agents to expose multiple transports, potentially at different URLs.
   *
   * Best practices:
   * - SHOULD include all supported transports for completeness
   * - SHOULD include an entry matching the main 'url' and 'preferredTransport'
   * - MAY reuse URLs if multiple transports are available at the same endpoint
   * - MUST accurately declare the transport available at each URL
   *
   * Clients can select any interface from this list based on their transport capabilities
   * and preferences. This enables transport negotiation and fallback scenarios.
   */
  additionalInterfaces?: AgentInterface[];
  /** An optional URL to an icon for the agent. */
  iconUrl?: string;
  /** Information about the agent's service provider. */
  provider?: AgentProvider;
  /**
   * The agent's own version number. The format is defined by the provider.
   *
   * @TJS-examples ["1.0.0"]
   */
  version: string;
  /** An optional URL to the agent's documentation. */
  documentationUrl?: string;
  /** A declaration of optional capabilities supported by the agent. */
  capabilities: AgentCapabilities;
  /**
   * A declaration of the security schemes available to authorize requests. The key is the
   * scheme name. Follows the OpenAPI 3.0 Security Scheme Object.
   */
  securitySchemes?: { [scheme: string]: SecurityScheme };
  /**
   * A list of security requirement objects that apply to all agent interactions. Each object
   * lists security schemes that can be used. Follows the OpenAPI 3.0 Security Requirement Object.
   * This list can be seen as an OR of ANDs. Each object in the list describes one possible
   * set of security requirements that must be present on a request. This allows specifying,
   * for example, "callers must either use OAuth OR an API Key AND mTLS."
   *
   * @TJS-examples [[{"oauth": ["read"]}, {"api-key": [], "mtls": []}]]
   */
  security?: { [scheme: string]: string[] }[];
  /**
   * Default set of supported input MIME types for all skills, which can be
   * overridden on a per-skill basis.
   */
  defaultInputModes: string[];
  /**
   * Default set of supported output MIME types for all skills, which can be
   * overridden on a per-skill basis.
   */
  defaultOutputModes: string[];
  /** The set of skills, or distinct capabilities, that the agent can perform. */
  skills: AgentSkill[];
  /**
   * If true, the agent can provide an extended agent card with additional details
   * to authenticated users. Defaults to false.
   */
  supportsAuthenticatedExtendedCard?: boolean;
  /** JSON Web Signatures computed for this AgentCard. */
  signatures?: AgentCardSignature[];
}
```

- `AgentProvider`： 有关提供代理的组织或实体的信息

```Python
export interface AgentProvider {
  /** The name of the agent provider's organization. */
  organization: string;
  /** A URL for the agent provider's website or relevant documentation. */
  url: string;
}
```

- `AgentCapabilities`：指定代理支持的可选 A2A 协议功能

```SQL
export interface AgentCapabilities {
  /** Indicates if the agent supports Server-Sent Events (SSE) for streaming responses. */
  streaming?: boolean;
  /** Indicates if the agent supports sending push notifications for asynchronous task updates. */
  pushNotifications?: boolean;
  /** Indicates if the agent provides a history of state transitions for a task. */
  stateTransitionHistory?: boolean;
  /** A list of protocol extensions supported by the agent. */
  extensions?: AgentExtension[];
}
```

- `AgentExtension`: 指定代理支持的 A2A 协议的扩展

```Go
export interface AgentExtension {
  /** The unique URI identifying the extension. */
  uri: string;
  /** A human-readable description of how this agent uses the extension. */
  description?: string;
  /**
   * If true, the client must understand and comply with the extension's requirements
   * to interact with the agent.
   */
  required?: boolean;
  /** Optional, extension-specific configuration parameters. */
  params?: { [key: string]: any };
}
```

- `SecurityScheme`: 描述访问代理端点的身份验证要求`url`

```JSON
export type SecurityScheme =
  | APIKeySecurityScheme
  | HTTPAuthSecurityScheme
  | OAuth2SecurityScheme
  | OpenIdConnectSecurityScheme
  | MutualTLSSecurityScheme;
```

- `AgentSkill`:  描述代理可以执行或解决的特定能力、功能或专业领域。

```Go
export interface AgentSkill {
  /** A unique identifier for the agent's skill. */
  id: string;
  /** A human-readable name for the skill. */
  name: string;
  /**
   * A detailed description of the skill, intended to help clients or users
   * understand its purpose and functionality.
   */
  description: string;
  /**
   * A set of keywords describing the skill's capabilities.
   *
   * @TJS-examples [["cooking", "customer support", "billing"]]
   */
  tags: string[];
  /**
   * Example prompts or scenarios that this skill can handle. Provides a hint to
   * the client on how to use the skill.
   *
   * @TJS-examples [["I need a recipe for bread"]]
   */
  examples?: string[];
  /**
   * The set of supported input MIME types for this skill, overriding the agent's defaults.
   */
  inputModes?: string[];
  /**
   * The set of supported output MIME types for this skill, overriding the agent's defaults.
   */
  outputModes?: string[];
  /**
   * Security schemes necessary for the agent to leverage this skill.
   * As in the overall AgentCard.security, this list represents a logical OR of security
   * requirement objects. Each object is a set of security schemes that must be used together
   * (a logical AND).
   *
   * @TJS-examples [[{"google": ["oidc"]}]]
   */
  security?: { [scheme: string]: string[] }[];
}
```

- `AgentInterface`: 提供目标 URL 和支持的传输协议组合的声明，以便与代理进行交互

```TypeScript
export enum TransportProtocol {
  JSONRPC = "JSONRPC", // JSON-RPC 2.0 over HTTP (mandatory)
  GRPC = "GRPC", // gRPC over HTTP/2 (optional)
  HTTP_JSON = "HTTP+JSON", // REST-style HTTP with JSON (optional)
}

export interface AgentInterface {
  /**
   * The URL where this interface is available. Must be a valid absolute HTTPS URL in production.
   * @TJS-examples ["https://api.example.com/a2a/v1", "https://grpc.example.com/a2a", "https://rest.example.com/v1"]
   */
  url: string;
  /**
   * The transport protocol supported at this URL.
   *
   * @TJS-examples ["JSONRPC", "GRPC", "HTTP+JSON"]
   */
  transport: TransportProtocol | string;
}
```

- `AgentCardSignature`: 表示用于验证 AgentCard 完整性的 JSON Web 签名

```Go
export interface AgentCardSignature {
  /**
   * The protected JWS header for the signature. This is a Base64url-encoded
   * JSON object, as per RFC 7515.
   */
  protected: string;
  /** The computed signature, Base64url-encoded. */
  signature: string;
  /** The unprotected JWS header values. */
  header?: { [key: string]: any };
}
```

## 3.2 AgentCard**必须**正确声明 URL 和传输协议之间的关系

主 URL 和首选传输: 

- **主 URL 要求**：该`url`字段**必须**指定代理的主要端点。
- **传输通信**：主服务器上可用的传输协议`url` **必须**与该`preferredTransport`字段匹配。
- **必需声明**：该`preferredTransport`字段是**必需的**，并且**必须**存在于每个中`AgentCard`。
- **传输****可用性**：主机`url` **必须**支持中声明的传输协议`preferredTransport`。

附加接口:

- **URL 唯一性**：为了清楚起见，每个`AgentInterface`URL 都`additionalInterfaces` **应该**指定一个不同的 URL，但如果同一端点有多个传输协议可用，**则可以重用 URL。**
- **传输声明**：每个`AgentInterface` **必须**准确声明其指定 URL 上可用的传输协议。
- **完整性**：该`additionalInterfaces`数组**应**包含所有支持的传输，包括主 URL 的传输以确保完整性。

## 3.3 客户端传输选择规则

客户端在选择传输方式时**必须遵循以下规则：**

1. **解析传输声明**：从主`url`/`preferredTransport`组合和所有中提取可用的传输`additionalInterfaces`。
2. **优先声明偏好**：如果客户端支持`preferredTransport`，它**应该**使用主`url`。
3. **后备选择**：如果客户端不支持首选传输，则它**可以**从中选择任何支持的传输`additionalInterfaces`。
4. **优雅降级**：如果客户端的首选传输失败，则客户端**应该**实施回退逻辑来尝试其他传输方式。
5. **URL 传输匹配**：客户端**必须**使用 AgentCard 中声明的所选传输协议的正确 URL。

## 3.4 验证要求

代理卡**必须**满足以下验证要求：

- **传输****一致性**：该`preferredTransport`值**必须**存在并且**必须**在主服务器上可用`url`。
- **接口完整性**：如果`additionalInterfaces`提供，它**应该**`url`包含与主接口和对应的条目`preferredTransport`。
- **无冲突**：同一个 URL**不得**在不同的接口声明中声明冲突的传输协议。
- **最低传输要求**：代理**必须**`url`通过主/`preferredTransport`组合或声明至少一个支持的传输协议`additionalInterfaces`。

```JSON
{
  "protocolVersion": "0.2.9",
  "name": "GeoSpatial Route Planner Agent",
  "description": "Provides advanced route planning, traffic analysis, and custom map generation services. This agent can calculate optimal routes, estimate travel times considering real-time traffic, and create personalized maps with points of interest.",
  "url": "https://georoute-agent.example.com/a2a/v1",
  "preferredTransport": "JSONRPC",
  "additionalInterfaces" : [
    {"url": "https://georoute-agent.example.com/a2a/v1", "transport": "JSONRPC"},
    {"url": "https://georoute-agent.example.com/a2a/grpc", "transport": "GRPC"},
    {"url": "https://georoute-agent.example.com/a2a/json", "transport": "HTTP+JSON"}
  ],
  "provider": {
    "organization": "Example Geo Services Inc.",
    "url": "https://www.examplegeoservices.com"
  },
  "iconUrl": "https://georoute-agent.example.com/icon.png",
  "version": "1.2.0",
  "documentationUrl": "https://docs.examplegeoservices.com/georoute-agent/api",
  "capabilities": {
    "streaming": true,
    "pushNotifications": true,
    "stateTransitionHistory": false
  },
  "securitySchemes": {
    "google": {
      "type": "openIdConnect",
      "openIdConnectUrl": "https://accounts.google.com/.well-known/openid-configuration"
    }
  },
  "security": [{ "google": ["openid", "profile", "email"] }],
  "defaultInputModes": ["application/json", "text/plain"],
  "defaultOutputModes": ["application/json", "image/png"],
  "skills": [
    {
      "id": "route-optimizer-traffic",
      "name": "Traffic-Aware Route Optimizer",
      "description": "Calculates the optimal driving route between two or more locations, taking into account real-time traffic conditions, road closures, and user preferences (e.g., avoid tolls, prefer highways).",
      "tags": ["maps", "routing", "navigation", "directions", "traffic"],
      "examples": [
        "Plan a route from '1600 Amphitheatre Parkway, Mountain View, CA' to 'San Francisco International Airport' avoiding tolls.",
        "{\"origin\": {\"lat\": 37.422, \"lng\": -122.084}, \"destination\": {\"lat\": 37.7749, \"lng\": -122.4194}, \"preferences\": [\"avoid_ferries\"]}"
      ],
      "inputModes": ["application/json", "text/plain"],
      "outputModes": [
        "application/json",
        "application/vnd.geo+json",
        "text/html"
      ]
    },
    {
      "id": "custom-map-generator",
      "name": "Personalized Map Generator",
      "description": "Creates custom map images or interactive map views based on user-defined points of interest, routes, and style preferences. Can overlay data layers.",
      "tags": ["maps", "customization", "visualization", "cartography"],
      "examples": [
        "Generate a map of my upcoming road trip with all planned stops highlighted.",
        "Show me a map visualizing all coffee shops within a 1-mile radius of my current location."
      ],
      "inputModes": ["application/json"],
      "outputModes": [
        "image/png",
        "image/jpeg",
        "application/json",
        "text/html"
      ]
    }
  ],
  "supportsAuthenticatedExtendedCard": true,
  "signatures": [
    {
      "protected": "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpPU0UiLCJraWQiOiJrZXktMSIsImprdSI6Imh0dHBzOi8vZXhhbXBsZS5jb20vYWdlbnQvandrcy5qc29uIn0",
      "signature": "QFdkNLNszlGj3z3u0YQGt_T9LixY3qtdQpZmsTdDHDe3fXV9y9-B3m2-XgCpzuhiLt8E0tV6HXoZKHv4GtHgKQ"
    }
  ]
}
```

# 四、Agent2Agent 任务

- 当客户端向代理发送消息时，代理可能会确定满足请求需要完成有状态的任务（例如，“生成报告”，“预订航班”，“回答问题”）。
- 每个任务都有一个由代理定义的唯一 ID，并按照定义的生命周期进行
- 任务是有状态的，并且可以涉及客户端和服务器之间的多个交换（消息）。

## 4.1 任务的生命周期

当消息发送给代理时，它可以选择使用以下任一方式回复：

- 无状态的`Message`。
- 一个有状态的`Task`后跟零个或多个`TaskStatusUpdateEvent`或`TaskArtifactUpdateEvent`。

如果响应为`Message`，则交互完成。另一方面，如果响应为`Task`，则代理将处理该任务，直到它处于中断状态（`input-required`或`auth-required`）或终止状态（`completed`、`cancelled`或`rejected`）`failed`。

### 4.1.1 上下文

`contextId`在逻辑上由许多`Task`对象和独立`Message`对象组成。如果 A2A 代理内部使用 LLM，则可以利用`contextId`来管理 LLM 上下文。

对于第一条消息，代理会使用服务器生成的进行响应`contextId`。如果代理创建了任务，它还会包含服务器生成的`taskId`。后续客户端消息可以包含相同的`contextId`以继续交互，也可以选择包含`taskId`以继续执行特定任务。

`contextId`允许针对一个目标进行协作或者在多个任务之间共享单个上下文会话。

### 4.1.2 代理：消息或任务

消息可用于无需长时间运行处理或协作的简单交互。代理可以使用消息来协商任务的接受情况。代理将传入消息的意图映射到支持的功能后，即可回复`Task`。

代理可以分为三个级别：

1. 始终仅使用对象进行响应的代理`Message`。它不进行复杂的状态管理，不执行长时间运行的执行，并使用 contextID 将消息绑定在一起。代理很可能直接封装了 LLM 调用和一些简单的工具。
2. 生成`Task`，做更多可追踪的实质性工作，并延长其使用寿命。
3. 生成`Message`和`Task`对象。使用消息协商代理能力和任务的工作范围。然后发送`Task`对象以跟踪其执行情况，并协作处理任务状态，例如需要更多输入、错误处理等。

代理可以选择始终使用`Task`对象进行回复，并将简单的响应建模为`completed`状态中的任务。

### 4.1.3 Task Refinements & Follow-ups

客户可能希望根据任务结果跟进新的请求，和/或改进任务结果。这可以通过使用与原始任务相同的开始另一个交互来实现。客户可以通过使用在对象`contextId`提供对原始任务的引用来进一步提示代理。然后，代理会以或进行响应。

一旦任务达到终止状态（`completed`、`cancelled`或） `rejected`，`failed`就无法重新启动。这样做有以下好处：

- **任务不变性**：客户端可以可靠地引用任务及其相关状态、工件和消息。
  - 这提供了输入到输出的清晰映射。
  - 对于将客户端编排器映射到任务执行很有用。
- **清晰的工作单元**：每个新请求、改进或后续行动都成为一项独特的任务，简化了簿记并允许对代理的工作进行细致的跟踪。
  - 每个工件都可以追溯到一个单位任务。
  - 此工作单元可以被父代理或其他系统（例如代理优化器）更精细地引用。对于可重启任务，所有后续细化操作都会被合并，任何对交互的引用都需要借助某种消息索引范围。
- **更易于实施**：对于代理开发人员来说，无论是创建新任务还是重启现有任务，都无需担心。一旦任务处于终止状态，任何相关的后续交互都需要在新任务中进行。

### 4.1.4 Parallel Follow-ups

通过让代理为同一contextId内发送的每条后续消息创建不同的并行任务，可以支持并行工作。这允许客户端跟踪各个任务，并在先决任务完成后立即创建新的依赖任务。

```HTML
Task 1: Book a flight to Helsinki.
(After Task 1 finishes)
Task 2: Based on Task 1, book a hotel.
Task 3: Based on Task 1, book a snowmobile activity.
(After Task 2 finishes, while Task 3 is still in progress)
Task 4: Based on Task 2, add a spa reservation to the hotel booking.
```

示例：客户端向代理发送

```JSON
{
  "jsonrpc": "2.0",
  "id": "req-001",
  "method": "message/send",
  "params": {
    "message": {
      "role": "user",
      "parts": [
        {
          "kind": "text",
          "text": "Generate an image of a sailboat on the ocean."
        }
      ],
      "messageId": "msg-user-001"
    }
  }
}
```

代理人用船的图片回应

```JSON
{
  "jsonrpc": "2.0",
  "id": "req-001",
  "result": {
    "id": "task-boat-gen-123",
    "contextId": "ctx-conversation-abc",
    "status": {
      "state": "completed",
    },
    "artifacts": [
      {
        "artifactId": "artifact-boat-v1-xyz",
        "name": "sailboat_image.png",
        "description": "A generated image of a sailboat on the ocean.",
        "parts": [
          {
            "kind": "file",
            "file": {
              "name": "sailboat_image.png",
              "mimeType": "image/png",
              "bytes": "<base64_encoded_png_data_of_a_sailboat>"
            }
          }
        ]
      }
    ],
    "kind": "task"
  }
}
```

## 4.2 协议数据对象

这些对象定义了 A2A 协议的 JSON-RPC 方法内交换的数据结构。

### 4.2.1 Task

表示 A2A 服务器为 A2A 客户端处理的有状态工作单元。任务封装了与特定目标或请求相关的整个交互。已达到最终状态（已完成、已取消、已拒绝或已失败）的任务无法重新启动。处于已完成状态的任务应使用工件将生成的输出返回给客户端。

```Go
export interface Task {
  /** A unique identifier for the task, generated by the server for a new task. */
  id: string;
  /** A server-generated identifier for maintaining context across multiple related tasks or interactions. */
  contextId: string;
  /** The current status of the task, including its state and a descriptive message. */
  status: TaskStatus;
  /** An array of messages exchanged during the task, representing the conversation history. */
  history?: Message[];
  /** A collection of artifacts generated by the agent during the execution of the task. */
  artifacts?: Artifact[];
  /** Optional metadata for extensions. The key is an extension-specific identifier. */
  metadata?: {
    [key: string]: any;
  };
  /** The type of this object, used as a discriminator. Always 'task' for a Task. */
  readonly kind: "task";
}
```

### 4.2.2 TaskStatus对象

表示的当前状态和相关上下文Task

```Go
export interface TaskStatus {
  /** The current state of the task's lifecycle. */
  state: TaskState;
  /** An optional, human-readable message providing more details about the current status. */
  message?: Message;
  /**
   * An ISO 8601 datetime string indicating when this status was recorded.
   *
   * @TJS-examples ["2023-10-27T10:00:00Z"]
   */
  timestamp?: string;
}
```

### 4.2.3 TaskState枚举

Task的生命周期状态

```C++
export enum TaskState {
  /** The task has been submitted and is awaiting execution. */
  Submitted = "submitted",
  /** The agent is actively working on the task. */
  Working = "working",
  /** The task is paused and waiting for input from the user. */
  InputRequired = "input-required",
  /** The task has been successfully completed. */
  Completed = "completed",
  /** The task has been canceled by the user. */
  Canceled = "canceled",
  /** The task failed due to an error during execution. */
  Failed = "failed",
  /** The task was rejected by the agent and was not started. */
  Rejected = "rejected",
  /** The task requires authentication to proceed. */
  AuthRequired = "auth-required",
  /** The task is in an unknown or indeterminate state. */
  Unknown = "unknown",
}
```

### 4.2.4 Message

表示客户端与Agent之间的单次沟通或一条上下文信息。消息用于指示、提示、回复和状态更新。

```Go
export interface Message {
  /** Identifies the sender of the message. `user` for the client, `agent` for the service. */
  readonly role: "user" | "agent";
  /**
   * An array of content parts that form the message body. A message can be
   * composed of multiple parts of different types (e.g., text and files).
   */
  parts: Part[];
  /** Optional metadata for extensions. The key is an extension-specific identifier. */
  metadata: {
    [key: string]: any;
  };
  /** The URIs of extensions that are relevant to this message. */
  extensions: string[];
  /** A list of other task IDs that this message references for additional context. */
  referenceTaskIds: string[];
  /** A unique identifier for the message, typically a UUID, generated by the sender. */
  messageId: string;
  /** The identifier of the task this message is part of. Can be omitted for the first message of a new task. */
  taskId: string;
  /** The context identifier for this message, used to group related interactions. */
  contextId: string;
  /** The type of this object, used as a discriminator. Always 'message' for a Message. */
  readonly kind: "message";
}
```

### 4.2.5 Part类型

`Message`表示或中的特定内容片段`Artifact`。 `Part`是一个联合类型，表示可导出为`TextPart`、`FilePart`的内容`DataPart`。所有`Part`类型还包含一个可选`metadata`字段 ( `Record<string, any>`)，用于指定特定部分的元数据。

```Go
export type Part = TextPart | FilePart | DataPart;

export interface PartBase {  /** Optional metadata associated with this part. */  metadata: {    
    [key: string]: any; 
  };
}

// 用于传达纯文本内容。
export interface TextPart extends PartBase {
  /** The type of this part, used as a discriminator. Always 'text'. */
  readonly kind: "text";
  /** The string content of the text part. */
  text: string;
}

// 用于传达基于文件的内容。
export interface FilePart extends PartBase {
  /** The type of this part, used as a discriminator. Always 'file'. */
  readonly kind: "file";
  /** The file content, represented as either a URI or as base64-encoded bytes. */
  file: FileWithBytes | FileWithUri;
}

// 用于传递结构化的 JSON 数据。适用于表单、参数或任何机器可读的信息。
export interface DataPart extends PartBase {
  /** The type of this part, used as a discriminator. Always 'data'. */
  readonly kind: "data";
  /** The structured data content. */
  data: {
    [key: string]: any;
  };
}
```

### 4.2.6 `FileBase`对象

文件内容的基本实体。

```Go
export interface FileBase {
  /** An optional name for the file (e.g., "document.pdf"). */
  name: string;
  /** The MIME type of the file (e.g., "application/pdf"). */
  mimeType: string;
}

// 代表文件的数据，在 中使用FilePart。
export interface FileWithBytes extends FileBase {
  /** The base64-encoded content of the file. */
  bytes: string;
  /** The `uri` property must be absent when `bytes` is present. */
  uri: never;
}

// 表示文件的 URI，在 内使用FilePart。
export interface FileWithUri extends FileBase {
  /** A URL pointing to the file's content. */
  uri: string;
  /** The `bytes` property must be absent when `uri` is present. */
  bytes: never;
}
```

### 4.2.7.`Artifact`对象

表示代理在执行任务期间生成的有效输出。

```Go
export interface Artifact {
  /** A unique identifier for the artifact within the scope of the task. */
  artifactId: string;
  /** An optional, human-readable name for the artifact. */
  name: string;
  /** An optional, human-readable description of the artifact. */
  description: string;
  /** An array of content parts that make up the artifact. */
  parts: Part[];
  /** Optional metadata for extensions. The key is an extension-specific identifier. */
  metadata: {
    [key: string]: any;
  };
  /** The URIs of extensions that are relevant to this artifact. */
  extensions: string[];
}
```

### 4.2.8 PushNotificationConfig

客户端向服务器提供的配置，用于发送有关任务更新的异步推送通知。

```Go
export interface PushNotificationConfig {
  /**
   * A unique ID for the push notification configuration, set by the client
   * to support multiple notification callbacks.
   */
  id: string;
  /** The callback URL where the agent should send push notifications. */
  url: string;
  /** A unique token for this task or session to validate incoming push notifications. */
  token: string;
  /** Optional authentication details for the agent to use when calling the notification URL. */
  authentication: PushNotificationAuthenticationInfo;
}
```

### 4.2.9.`PushNotificationAuthenticationInfo`对象

用于指定身份验证要求的通用结构，通常用于`PushNotificationConfig`描述 A2A 服务器如何向客户端的 webhook 进行身份验证。

```Go
export interface PushNotificationAuthenticationInfo {
  /** A list of supported authentication schemes (e.g., 'Basic', 'Bearer'). */
  schemes: string[];
  /** Optional credentials required by the push notification endpoint. */
  credentials: string;
}
```

### 4.2.10 TaskPushNotificationConfig

用作方法`params`的对象`tasks/pushNotificationConfig设置`，并将结构用作方法的`pushNotificationConfig获取`。

```Go
export interface TaskPushNotificationConfig {
  /** The ID of the task. */
  taskId: string;
  /** The push notification configuration for this task. */
  pushNotificationConfig: PushNotificationConfig;
}
```

### 4.2.11. JSON-RPC

A2A 遵循标准[JSON-RPC 2.0](https://www.jsonrpc.org/specification)结构进行请求和响应。

#### `JSONRPCRequest`对象

所有 A2A 方法调用都封装在 JSON-RPC 请求对象中。

- `jsonrpc`：指定 JSON-RPC 协议版本的字符串。**必须**完全一致`"2.0"`。
- `method`：包含要调用的方法的名称的字符串（例如`"message/send"`，，`"tasks/get"`）。
- `params`：一个结构化值，用于保存方法调用期间要使用的参数值。如果方法不需要参数，**则可以**`object`省略此成员。A2A 方法通常使用for循环`params`。
- `id`：客户端建立的标识符，**必须**包含字符串、数字或`NULL`值（如果包含）。如果不包含，则假定为通知。该值**不应用于**期望`NULL`响应的请求，且数字**不应**包含小数部分。服务器**必须**在 Response 对象中回复相同的值（如果包含）。此成员用于关联两个对象之间的上下文。A2A 方法通常期望响应或流，因此`id`通常会存在且非空。

#### `JSONRPCResponse`对象

A2A 服务器的响应封装在 JSON-RPC 响应对象中。

- `jsonrpc`：指定 JSON-RPC 协议版本的字符串。**必须**完全一致`"2.0"`。
- `id`：此成员是**必需的**。它**必须**与请求对象中成员的值相同`id`。如果在检测请求对象中的 时出现错误`id`（例如，解析错误/无效请求），则**必须**为`null`。
- `result`：成功时，此成员为**必需**。如果调用方法时出错，则此成员**不得存在。此成员的值由服务器上调用的方法决定。**
- `error`：失败时此成员为**必需**。如果调用期间未触发任何错误，则此成员**不得**存在。此成员的值**必须**为`JSONRPCError`对象。
- 成员`result`和`error`是互斥的：一个**必须**存在，而另一个**不能存在**。

```Go
export interface JSONRPCError {
  /**
   * A number that indicates the error type that occurred.
   */
  code: number;
  /**
   * A string providing a short description of the error.
   */
  message: string;
  /**
   * A primitive or structured value containing additional information about the error.
   * This may be omitted.
   */
  data?: any;
}
```

## 4.3 消息

- 表示客户端和代理之间的一次通信或通信单元。
- 消息具有`role`（无论是`"user"`客户端发送的消息还是`"agent"`服务器发送的消息）并包含一个或多个`Part`携带实际内容的对象。`messageId`消息对象的一部分是消息发送者为每条消息设置的唯一标识符。
- 用于传达指示、背景、问题、答案或状态更新，这些不一定是正式的，`Artifacts`但属于 的一部分`Task`。

## 4.4 **Part**

- `Message`或中内容的基本单位`Artifact`。每个部分都有特定的内容`type`，并且可以承载不同类型的数据：
  - `TextPart`：包含纯文本内容。
  - `FilePart`：表示一个文件，可以作为内联 Base64 编码字节传输，或通过 URI 引用。包含文件名和媒体类型等元数据。
  - `DataPart`：携带结构化的 JSON 数据，可用于表单、参数或任何机器可读的信息。

## 4.5 **Artifact**

- 表示远程代理在处理任务期间生成的有形输出或结果。
- 示例包括生成的文档、图像、电子表格、结构化数据结果或任何其他由任务直接产生的独立信息。
- 处于完成状态的任务应该使用工件对象将生成的输出返回给客户端。
- 工件由一个或多个对象组成`Part`，可以增量地进行流式传输。

# 五、交互机制 

- **请求/响应（轮询）：**
  - 客户端发送请求（例如，使用`message/send`RPC方法）并接收来自服务器的响应。
  - 如果交互需要有状态的长时间运行任务，服务器最初可能会以`working`状态进行响应。然后，客户端会定期调用`tasks/get`轮询来获取更新，直到任务达到终止状态（例如`completed`，`failed`）。

**流（服务器发送事件 - SSE）：**

- 对于逐步产生结果或提供实时进度更新的任务。
- 客户端使用 发起与服务器的交互`message/stream`。
- 服务器通过保持打开的 HTTP 连接进行响应，并通过该连接发送服务器发送事件 (SSE) 流。
- 这些事件可以是`Task`、`Message`或`TaskStatusUpdateEvent`（对于状态变化）或`TaskArtifactUpdateEvent`（对于新的或更新的工件块）。

**推送通知：**

- 对于长期运行的任务或维持持久连接（如 SSE）不切实际的场景。
- 客户端可以在启动任务时（或通过调用`tasks/pushNotificationConfig/set`）提供 webhook URL。
- 当任务状态发生重大变化（例如，完成、失败或需要输入）时，服务器可以向此客户端提供的 webhook 发送异步通知（HTTP POST 请求）。